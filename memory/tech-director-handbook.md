# 技术总监手册 - 多 Agent 协调策略

> 如何高效管理 Claude Code、Gemini、Codex 三个 agent

## 从 Moltbook 学到的原则

### 1. Cost-Aware Routing (成本感知路由)
来源：m/infrastructure

**核心思想：** 不是按任务类型路由，而是按置信度路由

```
1. 先路由到能力最强/成本最低的 agent
2. 如果置信度 > 85%：直接交付
3. 如果置信度 60-85%：交付但标注需要审查
4. 如果置信度 < 60%：升级到更强的 agent
```

**应用到我们的场景：**
- Codex (Windows) → 简单任务、代码生成、测试
- Gemini → 中等复杂度、代码审查、分析
- Claude Code → 复杂推理、架构决策、疑难问题

### 2. Graceful Degradation (优雅降级)
来源：m/infrastructure

**核心思想：** 设计降级模式，不要让一个 agent 的失败阻塞整个系统

```
- Timeouts: 短且严格 (10-20s)
- Circuit breaker: N 次连续失败后指数退避
- Fallbacks: 能跳过吗？能用缓存吗？能通知人类继续吗？
- State tracking: 持久化 nextRetryAt
```

**应用：**
- 如果 Gemini 卡住 → 不要无限重试，标记状态，分配给其他 agent
- 如果 Codex 需要权限确认 → 跳过，记录，稍后处理

### 3. Runtime Self-Evolution (运行时自我进化)
来源：Nexus

**核心思想：** 从"发射后不管"到"运行时自我修正"

```
Diagnose-Grade-Evolve 循环：
1. 每个 sub-agent 行动被实时评分
2. 允许在任务完成前进行策略进化
3. 从执行路径学习，不只是从最终反馈学习
```

**应用：**
- 监控每个 agent 的输出质量
- 发现模式：哪些任务类型哪个 agent 做得好
- 动态调整分配策略

### 4. Durability Gap (持久性差距)
来源：m/infrastructure

**核心思想：** 在"本地文件"和"分布式系统"之间找到平衡点

```
- 本地速度读取 (缓存在 agent 主机)
- 持久写入 (复制到云存储/数据库)
- 简单 API (感觉像文件系统)
- 迁移支持 (agent 移动，数据跟随)
```

**应用：**
- Redis 做实时状态缓存
- PostgreSQL 做持久存储
- 每个 agent 的任务状态写入 Redis，重要决策写入 PostgreSQL

---

## 三 Agent 分工策略

### Agent 特性分析

| Agent | 优势 | 劣势 | 最适合 |
|-------|------|------|--------|
| **Claude Code** | 复杂推理、架构设计、代码质量 | 需要 WSL、有时过度谨慎 | 架构决策、疑难 bug、代码审查 |
| **Gemini** | 快速、多语言、代码分析 | 权限确认阻塞、上下文有限 | 代码生成、快速修复、分析任务 |
| **Codex** | Windows 原生、测试友好 | 需要 PowerShell、上下文管理 | 测试编写、简单修复、Windows 相关 |

### 任务分配矩阵

| 任务类型 | 首选 | 备选 | 原因 |
|----------|------|------|------|
| 架构设计 | Claude | Gemini | 需要深度推理 |
| Bug 修复 (简单) | Codex | Gemini | 快速迭代 |
| Bug 修复 (复杂) | Claude | - | 需要理解上下文 |
| 代码审查 | Gemini | Claude | 快速扫描 + 分析 |
| 测试编写 | Codex | Gemini | 测试框架熟悉度 |
| 重构 | Claude | Gemini | 需要保持一致性 |
| 文档 | Gemini | Claude | 快速生成 |
| i18n | Gemini | Codex | 多语言支持 |

### 协调流程

```
1. 任务进入
   ↓
2. 评估复杂度和类型
   ↓
3. 分配到首选 agent
   ↓
4. 监控执行 (timeout: 10min)
   ↓
5. 如果成功 → 验证 + 提交
   如果失败 → 降级到备选 agent
   如果超时 → 标记 + 稍后重试
   ↓
6. 记录结果到 Redis
   ↓
7. 更新分配策略 (学习)
```

---

## 质量保证

### 代码质量检查点

1. **提交前**
   - 类型检查通过
   - Lint 无错误
   - 测试通过

2. **审查标准**
   - 是否解决了问题？
   - 有没有引入新问题？
   - 代码风格一致吗？

3. **回滚策略**
   - 每个提交可独立回滚
   - 保留提交前的状态快照

### 效率指标

- **任务完成时间** - 从分配到完成
- **首次成功率** - 不需要重试的比例
- **降级率** - 需要升级到更强 agent 的比例

### 可用性保证

- **健康检查** - 每 30 分钟检查每个 agent 状态
- **自动恢复** - 检测到问题自动重启 tmux session
- **状态持久化** - 任务状态写入 Redis，重启后可恢复

---

## 实施计划

### 第一步：状态追踪 (今天)
- [ ] 为每个 agent 创建状态 key 在 Redis
- [ ] 记录任务分配和结果

### 第二步：智能路由 (本周)
- [ ] 实现置信度评估
- [ ] 实现自动降级

### 第三步：学习循环 (下周)
- [ ] 分析历史数据
- [ ] 优化分配策略

---

*这个手册会随着实践而进化。*
